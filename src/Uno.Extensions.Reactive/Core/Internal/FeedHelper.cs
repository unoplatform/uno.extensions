using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Uno.Extensions.Reactive.Core;

internal static class FeedHelper
{
	/// <summary>
	/// Invokes an async method in reaction to a message from a parent feed
	/// </summary>
	/// <typeparam name="TParent">Value type of the parent feed</typeparam>
	/// <typeparam name="TResult">Value type of the resulting feed</typeparam>
	/// <param name="msgManager">The message manager used to produce new values messages.</param>
	/// <param name="parentMsg">Optionally provide the message from a parent feed which needs to be pushed to the <paramref name="msgManager"/> (cf. Remarks).</param>
	/// <param name="dataProvider">The async method to invoke.</param>
	/// <param name="extraConfig">Additional configure step for the messages produced while invoking the async method.</param>
	/// <param name="context">The context to use to invoke the async method.</param>
	/// <param name="ct">The enumerator cancellation.</param>
	/// <returns>
	/// An async enumerable that produces message that has to be forwarded (and stored as new current) by the resulting feed
	/// to track the progress the of the async method invocation.
	/// In best cases this will contains only one message (e.g. <paramref name="dataProvider"/> runs sync),
	/// and currently it will produces a maximum of 2 messages.
	/// </returns>
	/// <remarks>
	/// If this manager is used with a parent feed, instead of manually updating the parent of the
	/// <paramref name="msgManager"/> and then call this invoke helper,
	/// it's preferable to provide the <paramref name="parentMsg"/> to this helper,
	/// so the parent message will be updated in sync with other messages generated by this method,
	/// reducing the total number of messages generated.
	/// </remarks>
	public static async Task InvokeAsync<TParent, TResult>(
		MessageManager<TParent, TResult> msgManager,
		Message<TParent>? parentMsg,
		AsyncFunc<Option<TResult>> dataProvider,
		Action<MessageBuilder<TParent, TResult>>? extraConfig,
		SourceContext context,
		CancellationToken ct)
	{
		// Note: We DO NOT register the 'message' update transaction into ct.Register, so in case of a "Last wins" usage of this,
		//		 we allow the next updater to really preserver the pending progress axis.
		using var message = msgManager.BeginUpdate(preservePendingAxes: MessageAxis.Progress);
		using var _ = context.AsCurrent();

		ValueTask<Option<TResult>> dataTask = default;
		Exception? error = default;
		try
		{
			dataTask = dataProvider(ct);
		}
		catch (OperationCanceledException) when (ct.IsCancellationRequested)
		{
			return;
		}
		catch (Exception e)
		{
			error = e;
		}

		if (error is not null)
		{
			message.Commit(
				(m, @params) => m.With(@params.parentMsg).Apply(@params.extraConfig).Error(@params.error),
				(parentMsg, error, extraConfig));
			return;
		}

		// If we are not yet and the 'dataTask' is really async, we need to send a new message flagged as transient
		// Note: This check is not "atomic", but it's valid as it only enables a fast path.
		if (!message.Local.Current.IsTransient)
		{
			// As lot of async methods are actually not really async but only re-scheduled,
			// we try to avoid the transient state by delaying a bit the message.
			for (var i = 0; !dataTask.IsCompleted && !ct.IsCancellationRequested && i < 5; i++)
			{
				await Task.Yield();
			}

			if (ct.IsCancellationRequested)
			{
				return;
			}

			// The 'valueProvider' is not completed yet, so we need to flag the current value as transient.
			// Note: We also provide the parentMsg which will be applied
			if (!dataTask.IsCompleted)
			{
				message.Update(
					(msg, @params) =>
					{
						var builder = msg.With(@params.parentMsg);
						@params.extraConfig?.Invoke(builder.Inner);
						builder.SetTransient(MessageAxis.Progress, MessageAxis.Progress.ToMessageValue(true));
						return builder;
					},
					(parentMsg, extraConfig),
					ct);
			}
		}

		Option<TResult> data = default;
		try
		{
			data = await dataTask.ConfigureAwait(false);
		}
		catch (OperationCanceledException) when (ct.IsCancellationRequested)
		{
			return;
		}
		catch (Exception e)
		{
			error = e;
		}

		message.Commit(
			(msg, @params) =>
			{
				var builder = msg.With(@params.parentMsg).Apply(@params.extraConfig);
				if (@params.error is null)
				{
					// Clear the local error if any.
					// Note: Thanks to the MessageManager, this will NOT erase the parent's error!
					builder.Data(@params.data).Error(null);
				}
				else
				{
					builder.Error(@params.error);
				}

				return builder;
			},
			(parentMsg, data, error, extraConfig));
	}

	public static Exception? AggregateErrors(Exception? error1, Exception? error2)
	{
		if (error1 is null)
		{
			return error2;
		}

		if (error2 is null)
		{
			return error1;
		}

		List<Exception> errors = new();
		if (error1 is AggregateException aggregate1)
		{
			errors.AddRange(aggregate1.InnerExceptions);
		}
		else
		{
			errors.Add(error1);
		}
		if (error2 is AggregateException aggregate2)
		{
			errors.AddRange(aggregate2.InnerExceptions);
		}
		else
		{
			errors.Add(error1);
		}

		return new AggregateException(errors);
	}

	public static Exception AggregateErrors(IReadOnlyCollection<Exception> errors)
	{
		var flattened = errors
			.SelectMany(error => error switch
			{
				null => Enumerable.Empty<Exception>(),
				AggregateException aggregate => aggregate.InnerExceptions,
				_ => new[] { error }
			})
			.Distinct();

		return new AggregateException(flattened);
	}

	internal static string GetDebugIdentifier(object? feed)
		=> feed is null ? "--null--" : $"{feed.GetType().Name}_{feed.GetHashCode():X8}";
}
